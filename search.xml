<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>深入理解iptables工作原理</title>
    <url>/2019/12/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3iptables%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>今天刚好放假，有空来整理下iptables的工作原理。对于iptables/netfilter的接触，还是之前研究k8s service load balancing 时深入学习了下工作原理。</p>
<h2 id="概念理解"><a href="#概念理解" class="headerlink" title="概念理解"></a>概念理解</h2><p>下面摘录下官方的定义：</p>
<blockquote>
<p><a href="https://netfilter.org/" target="_blank" rel="noopener">netfilter</a> is a set of hooks inside the Linux kernel that allows kernel modules to register callback functions with the network stack. A registered callback function is then called back for every packet that traverses the respective hook within the network stack.</p>
</blockquote>
<blockquote>
<p><a href="https://netfilter.org/" target="_blank" rel="noopener">iptables</a> is a generic table structure for the definition of rulesets. Each rule within an IP table consists of a number of classifiers (iptables matches) and one connected action (iptables target).</p>
</blockquote>
<p>翻译下也就是说啊：netfilter是内核空间的hook，允许内核模块向网络协议栈里面注册回调函数(详细netfilter定义请参考<a href="https://www.netfilter.org/documentation/HOWTO/netfilter-hacking-HOWTO-1.html#ss1.1" target="_blank" rel="noopener">netfilter</a>)。iptables是用户空间的用于定义规则集的通用表结构(详细iptables定义请参考<a href="https://netfilter.org/projects/iptables/index.html" target="_blank" rel="noopener">iptables</a>)。</p>
<h2 id="iptables和netfilter关系"><a href="#iptables和netfilter关系" class="headerlink" title="iptables和netfilter关系"></a>iptables和netfilter关系</h2><p>上面说到Netfilter定义了些hooks，其实他定义了5种hook point(我们可以理解为回调函数点，数据包到达这些位置的时候会主动调用这些函数，使我们有机会能在数据包路由的时候改变它们的方向、内容).分别是PREROUTING，INPUT， OUTPUT, FORWARD, POST_ROUNTING。下面是5个钩子的调用顺序：<img src="/images/iptables/first.png" alt></p>
<p>而 iptables 说到是一个用户空间的应用程序，它通过 Netfilter 放出的接口来对存放在内核内存中的 XXtables（Netfilter的配置表）进行修改.这个xxtables 就是有tables , chains, rules 组成. iptables在应用层负责修改这个规则文件.下面是两者系统中的关系：<img src="/images/iptables/kernal_hook.png" alt></p>
<h2 id="Iptables可操作的配置表"><a href="#Iptables可操作的配置表" class="headerlink" title="Iptables可操作的配置表"></a>Iptables可操作的配置表</h2><p>上面讲到iptables通过修改Netfilter暴露出来的配置表，进而实现数据包过滤、数据包处理、地址伪装、透明代理、动态网络地址转换(Network Address Translation，NAT)等功能。那么下面就讲讲Netfilter暴露出了哪些配置表呢！</p>
<p>上面也有提到，其实这些配置表就是Tables，Chains 和Rules组成。</p>
<h3 id="Tables"><a href="#Tables" class="headerlink" title="Tables"></a>Tables</h3><p>官方定义了下面5种<a href="http://ipset.netfilter.org/iptables.man.html#lbAH" target="_blank" rel="noopener">tables</a>。</p>
<blockquote>
<p><strong>Filter</strong>: This is the default table (if no -t option is passed). It contains the built-in chains <strong>INPUT</strong> (for packets destined to local sockets), <strong>FORWARD</strong> (for packets being routed through the box), and <strong>OUTPUT</strong> (for locally-generated packets).</p>
</blockquote>
<blockquote>
<p><strong>Nat</strong>: This table is consulted when a packet that creates a new connection is encountered. It consists of four built-ins: <strong>PREROUTING</strong> (for altering packets as soon as they come in), <strong>INPUT</strong> (for altering packets destined for local sockets), <strong>OUTPUT</strong> (for altering locally-generated packets before routing), and <strong>POSTROUTING</strong> (for altering packets as they are about to go out). IPv6 NAT support is available since kernel 3.7.</p>
</blockquote>
<blockquote>
<p><strong>Mangle</strong>: This table is used for specialized packet alteration. Until kernel 2.4.17 it had two built-in chains: <strong>PREROUTING</strong> (for altering incoming packets before routing) and <strong>OUTPUT</strong> (for altering locally-generated packets before routing). Since kernel 2.4.18, three other built-in chains are also supported: <strong>INPUT</strong> (for packets coming into the box itself), <strong>FORWARD</strong> (for altering packets being routed through the box), and <strong>POSTROUTING</strong> (for altering packets as they are about to go out).</p>
</blockquote>
<blockquote>
<p><strong>Raw</strong>: This table is used mainly for configuring exemptions from connection tracking in combination with the NOTRACK target. It registers at the netfilter hooks with higher priority and is thus called before ip_conntrack, or any other IP tables. It provides the following built-in chains: <strong>PREROUTING</strong> (for packets arriving via any network interface) <strong>OUTPUT</strong> (for packets generated by local processes)</p>
</blockquote>
<blockquote>
<p><strong>Security</strong>: This table is used for Mandatory Access Control (MAC) networking rules, such as those enabled by the SECMARK and CONNSECMARK targets. Mandatory Access Control is implemented by Linux Security Modules such as SELinux. The security table is called after the filter table, allowing any Discretionary Access Control (DAC) rules in the filter table to take effect before MAC rules. This table provides the following built-in chains: <strong>INPUT</strong> (for packets coming into the box itself), <strong>OUTPUT</strong> (for altering locally-generated packets before routing), and <strong>FORWARD</strong> (for altering packets being routed through the box).</p>
</blockquote>
<h3 id="Chains"><a href="#Chains" class="headerlink" title="Chains"></a>Chains</h3><p>每个Table都有内置支持的Chains，每个Chain是一个可以匹配一组包的Rule列表。，具体参考上面Tables中官网定义(黑色标注)。</p>
<h3 id="Rules"><a href="#Rules" class="headerlink" title="Rules"></a>Rules</h3><p>每个Rule指定如何处理匹配的包。这称为“Target”，它可能是跳转到同一表中的用户定义Chain。每个Rule定义了一个Packet和一个Target的标准，如果Packet没有被匹配，Chain中的下一条Rule就会被检查，如果匹配上了，下一个Rule将被这个Rule的Target的值(可以是用户定义的Chain)指定。</p>
<h3 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h3><p>上面概念讲的有些难以理解。下面这张图可以很好地理解其工作流程！<img src="/images/iptables/match_flow.png" alt></p>
<p>从图中，我们可以总结出以下规律：<br>当一个数据包进入网卡时，数据包首先进入<strong>PREROUTING链</strong>，在PREROUTING链中我们有机会修改数据包的DestIP(目的IP)，然后内核的”路由模块”根据”数据包目的IP”以及”内核中的路由表”判断是否需要转送出去(注意，这个时候数据包的DestIP有可能已经被我们修改过了)<br>如果数据包就是进入本机的(即数据包的目的IP是本机的网口IP)，数据包就会沿着图向下移动，到达<strong>INPUT链</strong>。数据包到达INPUT链后，然后我们的应用程序就会收到。<br>当我们应用程序发送数据包时，这些数据包经过<strong>OUTPUT链</strong>，然后到达<strong>POSTROTING链</strong>输出(注意，这个时候数据包的SrcIP有可能已经被我们修改过了)。<br>如果数据包是要转发出去的(即目的IP地址不再当前子网中)，且内核允许转发，数据包就会向右移动，经过<strong>FORWARD链</strong>，然后到达<strong>POSTROUTING链</strong>输出(选择对应子网的网口发送出去)。</p>
<h2 id="Iptables-命令格式"><a href="#Iptables-命令格式" class="headerlink" title="Iptables 命令格式"></a>Iptables 命令格式</h2><p>命令格式可参考下图：<img src="/images/iptables/command.png" alt></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>对于Iptables和Netfilter的使用还是蛮多的， 网上很多都是在防火墙方面的使用。但是我接触这个不是因为防火墙方便的需求，而是在K8s和istio中使用了这个机制做load balancing及路由转发，所以才去深入了解了下。后续会总结下K8s kube_proxy中使用Iptables/Netfilter去做路由转发和load balancing的文章。</p>
<h2 id="参考-amp-鸣谢"><a href="#参考-amp-鸣谢" class="headerlink" title="参考&amp;鸣谢"></a>参考&amp;鸣谢</h2><p><a href="https://www.netfilter.org/" target="_blank" rel="noopener">Netfilter Official Site</a><br><a href="http://ipset.netfilter.org/iptables.man.html#index" target="_blank" rel="noopener">Iptables Man</a><br><a href="https://www.cnblogs.com/zllong/p/7236881.html" target="_blank" rel="noopener">Linux之iptables原理详解</a><br><a href="https://www.thegeekstuff.com/2011/01/iptables-fundamentals/" target="_blank" rel="noopener">Linux Firewall Tutorial: IPTables Tables, Chains, Rules Fundamentals</a></p>
]]></content>
      <categories>
        <category>iptables</category>
      </categories>
      <tags>
        <tag>iptables</tag>
        <tag>netfilter</tag>
      </tags>
  </entry>
  <entry>
    <title>gerrit自动添加reviewers</title>
    <url>/2019/12/gerrit%E8%87%AA%E5%8A%A8%E6%B7%BB%E5%8A%A0reviewers/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>我想用过gerrit的同学都知道，这个真的是个神code review工具，可以verify, view,还可以cherry-pick等等功能。这里我不做过多解释。有需要的可以自行百度了解基本知识。<br><a id="more"></a><br>但是就是有一点困惑我很长时间，就是每次一个新的commit，就要加上整个team的同事review(至于为什么要加整个team的，主要是PM规定的，说是多人review，提高代码质量)。所以每次一个新的commit，就要去网页上，加上一整个team的人进去，平时可能你不会觉得怎么样。但是我现在做微服务开发，经常没事所有的services 用的sidecar的tag换一遍，所以很多个service都要修改，提交。也许你会说，写个脚本就不就好了嘛，是的。我们写了个脚本，可以自动修改，然后commit。但是还是要手动去加members 去review，很麻烦(尤其是网络不稳定的时候)。然后翻墙找了下，原来人家gerrit 早就提供了命令可以在push commit的时候加人review。我写了个简单的脚本，在这里记录备忘下。可以翻墙的，推荐看官方文档<a href="https://gerrit-review.googlesource.com/Documentation/user-upload.html#push_create" target="_blank" rel="noopener">GERRIT_REVIEW</a>，讲解很详细。</p>
<h2 id="Script实现"><a href="#Script实现" class="headerlink" title="Script实现"></a>Script实现</h2><p>这个脚本很简单，就是把你想要添加的reviewers的邮箱编写到一个文件中，然后读出来，拼接在git push 命令后面。</p>
<p><strong>auto_add_reviewers.sh的内容:</strong><br><figure class="highlight awk"><table><tr><td class="code"><pre><span class="line"><span class="comment">#/bin/sh</span></span><br><span class="line"><span class="comment"># auto commit and add reviewers</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [ <span class="variable">$#</span> -ne <span class="number">3</span> ]</span><br><span class="line">then </span><br><span class="line">echo <span class="string">"usage:$0 repo_name branch_name maillist_filename"</span></span><br><span class="line"><span class="keyword">exit</span></span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">repo=<span class="variable">$1</span></span><br><span class="line">branch=<span class="variable">$2</span></span><br><span class="line">maillist_file=<span class="variable">$3</span></span><br><span class="line"></span><br><span class="line">maillists=<span class="string">""</span></span><br><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> `cat <span class="variable">$maillist_file</span>`</span><br><span class="line"><span class="keyword">do</span> </span><br><span class="line">maillists+=<span class="string">"r=$line,"</span></span><br><span class="line">done</span><br><span class="line"></span><br><span class="line">cd <span class="variable">$repo</span></span><br><span class="line">git push origin HEAD:refs<span class="regexp">/for/</span><span class="variable">$branch</span>%<span class="variable">$&#123;maillists%?&#125;</span></span><br></pre></td></tr></table></figure></p>
<p><strong>maillist.txt的内容:</strong><br><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="symbol">zhangsan@</span><span class="number">163.</span>com</span><br><span class="line"><span class="symbol">lisi@</span><span class="number">163.</span>com</span><br><span class="line"><span class="symbol">wangwu@</span><span class="number">163.</span>com</span><br></pre></td></tr></table></figure></p>
<p><strong>参考命令:</strong><br><figure class="highlight crmsh"><table><tr><td class="code"><pre><span class="line">./auto_add_reviewers.sh test_repo <span class="keyword">master</span> <span class="title">maillist</span>.txt</span><br></pre></td></tr></table></figure></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>之所以我把maillist单独提出一个文件来，一是为了方便修改，添加，另一方面是人太多的话，直接加在push后面，会很难维护。</p>
<p>关于这个脚本还有，就是在新建commit的时候使用下就好了，后面patch的时候，并不需要再用了，因为此时这个commit已经添加了所有想要添加的reviewers了。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考:"></a>参考:</h2><p>gerrit offcial site: <a href="https://gerrit-review.googlesource.com/Documentation/user-upload.html#push_create" target="_blank" rel="noopener">GERRIT_REVIEW</a>(需要翻墙)</p>
]]></content>
      <categories>
        <category>Others</category>
      </categories>
      <tags>
        <tag>Gerrit</tag>
      </tags>
  </entry>
  <entry>
    <title>谈谈我对CSDN的个人感受</title>
    <url>/2019/12/%E8%B0%88%E8%B0%88%E6%88%91%E5%AF%B9CSDN%E7%9A%84%E4%B8%AA%E4%BA%BA%E6%84%9F%E5%8F%97/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><strong>CSDN尽然拒绝了我这篇文章的发表！！！ Are you kidding me?</strong> \<br><img src="/images/csdn.png" alt="&quot;csdn拒绝了这篇文章&quot;"></p>
<a id="more"></a>
<h1 id="谈谈我对CSDN的个人感受"><a href="#谈谈我对CSDN的个人感受" class="headerlink" title="谈谈我对CSDN的个人感受"></a>谈谈我对CSDN的个人感受</h1><p>不知不觉已经在CSDN有6个年头了，多多少少也写了不少blog了。但是我想这应该是我最后一次更新CSDN blog了，后面将只在<a href="http://luffyao.com/" target="_blank" rel="noopener">luffyao’s blog</a> 上更新blog了。下面我将来谈谈我这些年的感受吧！</p>
<p>回想开始使用CSDN的时候 ，那还是在大学的时候，当时CSDN在校园圈内可是号称国内最好的程序员的网站了。你可以在CSDN上写blog,可以上传自己宝贵的资料供别人下载，可以下载别人分享的资料。那时候还是用的下载积分（如果我没记错了话，因为我已经很长时间没有玩那个了。后面我会说我的原因）， 还有一个论坛功能， 集成了很多模块， 你有任何问题都可以上去发个帖，提问就像以前百度贴吧差不多。其他功能我没有接触过。我就不做评价了。下面我将从这三个主要模块 来谈谈我6年来的感受吧！</p>
<h2 id="论坛模块"><a href="#论坛模块" class="headerlink" title="论坛模块"></a>论坛模块</h2><p>这个模块从我刚开始接触就有了。我也在上面提过几个问题。但是，但是，但是基本上没有人回过问题。所以，基本上没有关注这个模块，因为对于我来说，这个模块就是鸡肋，也许对于小白来说，还是有点用的。因为我以前还是时常能看到一些人问些基本问题，什么数组越界啦，指针怎么玩啦，，等，这些还是有些人回答的，但是好像也都是些小白在讨论学习。后来想想也是，有多少大牛 ，没事泡在这个论坛里面给你回答小白问题。</p>
<h2 id="下载模块"><a href="#下载模块" class="headerlink" title="下载模块"></a>下载模块</h2><p>说实话，这个模块 还是很有帮助的。比如你需要什么代码，书籍，什么的，你基本上都可以在这里找到，虽然可能只是扫描版的书籍，有很多bug的代码。但是这些都还是很有帮助的。但是，我不得不吐槽的就是积分制度。下载资源是需要积分的，所以你不得不upload自己的资源赚取积分，（<strong>如果你是土豪， 你可以忽略这个</strong>）记得几年前，别人下载需不需要积分是你自己upload时候自己填写的，我想这个还算人性化，因为你upload的资料的价值 ，你自己是最清楚地。而且还有那些总是有分享精神的人，他们免积分 给你下载。</p>
<p>后来，后来，不知道什么时候，突然，我去看了下我上传的资源，突然发现我本来设置免积分的资源竟然需要50个积分下载。以前10积分下载的就变成5积分了。我一阵诧异，然后度娘了下，既然发现是CSDN自己调的。 我就很纳闷，你凭什么调别人的资源下载积分呢？ 你知道别人的资源价值吗？也许别人就是愿意免费给别人下载呢？（我不知道它修改的逻辑是什么，但是就算你有大数据 统计支撑，也不应该修改别人的东西吧，毕竟这是每个用户的权限吧，就像淘宝一样，一样的东西，什么价格，每个商家自己决定的，难道淘宝一下 给你们修改成它想要的价格么！！！）从那以后，我再也没有上传过任何资源在这个模块了。至于下载（可能现在我需要的资料都可以在官网上下载的到，所以 基本上没有用过CSDN的下载资源了，基本上有时会把账号给我同学去下载，因为他们没有积分或者没有账号）。 其实关于积分，我还有一个地方要吐槽下，不知道为什么，积分好像会清零了。我没有深入理解这个，因为我不玩这个模块了。也没有太注意这个。任他去了。但是还是不得不吐槽下。这是为了让别人开会员，花钱下载么？</p>
<h2 id="博客模块"><a href="#博客模块" class="headerlink" title="博客模块"></a>博客模块</h2><p>这个模块是我用的最多的，因为我时常还是会记录下日常遇到的问题，总结下写在这里，自己备忘，也可以分享给那些遇到同样问题的人。开始接触CSDN 写blog的时候，blog界面还是很整洁干净的。各个子模块 layout 还是很清晰的。但是可能是因为商业问题，现在的blog上都加入了广告。好吧，这个可以理解。毕竟人家提供平台给你写文章，他自己做广告赚点钱还是可以理解的。还有就是这个广告 不影响你正常阅读，搜索。</p>
<p>还有就是你会发现，在搜索引擎所搜出来CSDN的文章很多都是大同小异的，更是有很多都是一样的。还都是原创的。所以这样会导致你查找解决问题的效率。可能这和CSDN平台，并没有多少关系，因为平台也不能控制用户做什么。但是这点还是我想吐槽的地方。（这个我为什么提出来呢，因为我的很多同学都有这样的感受，都基本上放弃了，表现一般是，搜索出来的不会优先点CSDN的blog了）</p>
<p>最让我感到难受的是blog下面那一推推荐文章 真的很让人难受。我是真心不知道这个子模块是干啥用的。让你快速看到相关资料的文章？让你能更快的找到问题解决方案？就算是这个原因，我看到的也就是开头几篇文章是相关的。后面的都是什么鬼东西。。i don’t know what it is！！！还有一个我不知道你们有没有遇到过，反正我是遇到过太多次。就是我每次在百度各浏览器上搜索，然后搜索出相关CSDN文章，结果 点进去,全篇阅读完，没有你想要的相关内容。开始我很纳闷，什么情况? 搜索引擎有问题？然后 我有次闲的，把整个blog看了遍，包括下面推荐的文章，然后发现，搜索引擎匹配的是下面推荐的文章的内容。 …………………..（此处省略一万字）。 大哥，你这样真的好么？你不能让那个文章排在前面么。你这样做的目的是什么？对于我来说就是浪费时间，再说有多少人去会看下面推荐的文章？一般都是看到内容不匹配都直接去浏览器找另外一个吧。所以我觉得下面那个推荐的就是个累赘。还有就是文章长了点，还会自己就收起来了，想要看全部内容，还要点下。很多次网络不好的情况，你点开后，然后又被收回去了。更有情况，你搞半天终于打开全部的内容了，然后通篇读完， 我靠，一点和你相关的内容都没有。真TM 想骂人的节奏。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>好了，到这里，我也吐槽的差不多了。对于CSDN，吐槽归吐槽，但是还是很感谢，毕竟在我程序员的道路，还是帮助了不少。只是我觉得它对于我们程序员来说，并没有当年那么有影响力了。也许是现在像腾讯云，知乎，阿里云等不少国内不错的社区，发展起来了吧。对于我来说，那些平台上的文章更有质量一点。</p>
<p>好了，最后要和CSDN‘s blog说再见了！感谢陪了我6年美好时光！！！</p>
]]></content>
      <categories>
        <category>日常随笔</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>C++ 17 尝鲜之 the overload pattern</title>
    <url>/2019/12/C-17-%E5%B0%9D%E9%B2%9C%E4%B9%8B-the-overload-pattern/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>以前在C++98的时候，咱们想要操作符重载怎么办？我们一般都是会将想要重载的操作符在自己的class或者struct里面写一遍。</p>
<p>一般大家写出来的代码无非和我的差不多。<br><a id="more"></a><br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">PrintVisitor</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span>&amp; i)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"int: "</span> &lt;&lt; i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">float</span>&amp; f)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"float: "</span> &lt;&lt; f;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">string</span>&amp; s)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"string: "</span> &lt;&lt; s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>C++17对于这种情况做了代码优化，引入了Overload Pattern。之后我们就可以像下面这样写了。看起来很难懂(<strong>是真的很难理解</strong>)， 但是代码比较简洁了。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span>... <span class="title">Ts</span>&gt; <span class="title">struct</span> <span class="title">overload</span> :</span> Ts... &#123; <span class="keyword">using</span> Ts::<span class="keyword">operator</span>()...; &#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span>... <span class="title">Ts</span>&gt; <span class="title">overload</span>(<span class="title">Ts</span>...) -&gt; <span class="title">overload</span>&lt;Ts...&gt;;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::variant&lt;<span class="keyword">int</span>, <span class="keyword">float</span>&gt; intFloat &#123; <span class="number">0.0f</span> &#125;;</span><br><span class="line"><span class="built_in">std</span>::visit(overload(</span><br><span class="line">        [](<span class="keyword">const</span> <span class="keyword">int</span>&amp; i) &#123; ... &#125;,</span><br><span class="line">        [](<span class="keyword">const</span> <span class="keyword">float</span>&amp; f) &#123; ... &#125;,</span><br><span class="line">    ),</span><br><span class="line">    intFloat;</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>总之，C++新的标准，相对于老版本来说，高大上了不少，也更加现代化了，更加降低了使用者的入门基础了(简单的一个例子就是，以前让C++程序员最头疼的指针，也是在C++11的时候引入了智能指针)。</p>
]]></content>
      <categories>
        <category>CPlusPlus</category>
      </categories>
      <tags>
        <tag>C++17</tag>
      </tags>
  </entry>
  <entry>
    <title>C++17 尝鲜之 structured bindings</title>
    <url>/2019/12/C-17-%E5%B0%9D%E9%B2%9C%E4%B9%8B-structured-bindings/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>老版本的C++函数返回值都是只有一个内嵌类型或者自定义类型。所以 以前 我们如果想要返回多个值，就必须将其封装为struct， 然后在将其返回。<br><a id="more"></a><br>但是C++17 引入了Structured Bindlings 这个特性。他是通过 <strong><em>std::tuple, std::pair, std::array, and aggregate structures</em></strong> 来实现多个返回值。</p>
<p>下面来个例子， 更加直观的欣赏C++17 的魅力：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;tuple&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">std</span>:</span>:tuple&lt;<span class="keyword">bool</span>, <span class="built_in">std</span>::<span class="built_in">string</span>&gt; testStructBinding(<span class="keyword">const</span> T&amp; doc) &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (doc)&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="literal">true</span>, <span class="built_in">std</span>::<span class="built_in">string</span>(<span class="string">"doc is true"</span>)&#125;;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="literal">false</span>, <span class="built_in">std</span>::<span class="built_in">string</span>(<span class="string">"doc is false"</span>)&#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">bool</span> doc = <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">auto</span>[testFlag, description] = testStructBinding(doc);</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"testFlag :"</span> &lt;&lt; testFlag &lt;&lt; <span class="string">" description :"</span> &lt;&lt; description &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>现在看看，上面的代码是不是就感觉很高大上了。咱们C++也能返回多返回值了！</p>
]]></content>
      <categories>
        <category>CPlusPlus</category>
      </categories>
      <tags>
        <tag>C++17</tag>
      </tags>
  </entry>
  <entry>
    <title>如何抓取pod中的container的tcpdump</title>
    <url>/2019/12/%E5%A6%82%E4%BD%95%E6%8A%93%E5%8F%96pod%E4%B8%AD%E7%9A%84container%E7%9A%84tcpdump/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>一般情况下，想要抓取pod中的某个container的tcpdump，直接kubectl exec 进入那个container，然后就可以抓取了。但是如果当你的image没有安装bash等shell terminal，那我们就不能使用exec进入container了。所以此时我们就需要以下方法，通过自己编一个带有shell的image，然后docker exec 嵌入到pod中，再进行抓取tcpdump。<br><a id="more"></a></p>
<h2 id="自己build一个装有tcpdump的image"><a href="#自己build一个装有tcpdump的image" class="headerlink" title="自己build一个装有tcpdump的image"></a>自己build一个装有tcpdump的image</h2><ul>
<li><p>先pull 一个base image alpine:3.9.2，然后docker run 这个image，在进入对应的container，安装tcpdump，再开另一个terminal，提交生成一个新的image。下面命令可供参考：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run -it --name=alpine alpine:3.9.2</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> install tcpdump</span></span><br><span class="line">apk add tcpdump</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> switch another terminal and <span class="built_in">exec</span> this <span class="built_in">command</span></span></span><br><span class="line">docker commit alpine aaa:tag</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="抓取tcpdump"><a href="#抓取tcpdump" class="headerlink" title="抓取tcpdump"></a>抓取tcpdump</h2><ul>
<li>将你的image运行，然后嵌到想要的container的network上，然后进入到你自己image运行的container里面抓取tcpdump。  <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> display all of the container and found containerId that you want.</span></span><br><span class="line">docker ps | grep your service</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="keyword">if</span> you want to copy tcpdump file out to container into <span class="built_in">local</span>, you should reference step3. </span></span><br><span class="line">docker run -it --rm --net=container:containerID aaa:tag</span><br><span class="line"></span><br><span class="line">tcpdump -i lo -w lo.pcap</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">or <span class="keyword">if</span> you want to grap all dump, you can use following <span class="built_in">command</span></span></span><br><span class="line">tcpdump -i any -w any.pcap</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="将tcpdump文件拷出container到本地-用wireshark进行分析"><a href="#将tcpdump文件拷出container到本地-用wireshark进行分析" class="headerlink" title="将tcpdump文件拷出container到本地,用wireshark进行分析"></a>将tcpdump文件拷出container到本地,用wireshark进行分析</h2><ul>
<li><p>我是通过挂载的方式，将本地创建的volume挂到container里面的某个目录，然后将coredump文件生成在container里面的那个目录，然后在本地就可以看到对于的文件了。将对应文件拷出，进去wireshark分析就好了。(其实我之前有提到过docker cp这个命令也可以copy文件,也许更为简单。具体怎么使用,可以参考官网指导 <a href="https://docs.docker.com/engine/reference/commandline/cp/" target="_blank" rel="noopener">docker cp command guidance</a>.)</p>
  <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> create a volume name is data.</span></span><br><span class="line">docker volume create data </span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> view detailed message .</span></span><br><span class="line">docker inspect data </span><br><span class="line"></span><br><span class="line">docker run -it --rm --net=container:containerID --mount source=data,destination=/dir aaa:tag</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>其实在pod里面抓取tcpdump 还是蛮重要的，因为当你一个pod里面有几个container的时候，内部的消息，其实在pod外面是抓取不到的。那只能想办法到pod里面去抓。但是一般都为了安全起见，产品的image并没有bash可以让你进到container里面。那我这个方法就有很大用处了。</p>
]]></content>
      <categories>
        <category>MicroService</category>
      </categories>
      <tags>
        <tag>Docker</tag>
        <tag>tcpdump</tag>
      </tags>
  </entry>
  <entry>
    <title>如何在pod中的container里面生成coredump文件并拷贝出来使用GDB debug</title>
    <url>/2019/12/%E5%A6%82%E4%BD%95%E5%9C%A8pod%E4%B8%AD%E7%9A%84container-%E9%87%8C%E9%9D%A2%E7%94%9F%E6%88%90coredump-%E6%96%87%E4%BB%B6-%E5%B9%B6%E6%8B%B7%E8%B4%9D%E5%87%BA%E6%9D%A5%E4%BD%BF%E7%94%A8GDB-debug/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>为什么会记录这篇文章呢，是因为在工作中，遇到了这个问题，由于我们这个是C++写的代码，crash tracing 并没有golang好，所以代码crash在pod中的container里面，很难调查。最多的也就是多加log，但是你懂的，添加log debug效率还是蛮低的。所以就要用coredump 去快速找到问题所在。但是就遇到文章的问题。你怎么去pod中的container生成coredump呢，然后拷到本地gdb呢?<br><a id="more"></a></p>
<h2 id="在helm-chart-里面加上一个initContainer"><a href="#在helm-chart-里面加上一个initContainer" class="headerlink" title="在helm chart 里面加上一个initContainer"></a>在helm chart 里面加上一个initContainer</h2><ul>
<li><p>在deployment.yaml 里面添加一个initContainer 和volume</p>
 <figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">volumes:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">dumps</span></span><br><span class="line">  <span class="attr">emptyDir:</span> <span class="string">&#123;&#125;</span></span><br><span class="line"><span class="attr">initContainers:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">&#123;&#123;</span> <span class="string">.Values.initContainers.coredumps.service.name</span> <span class="string">&#125;&#125;</span></span><br><span class="line">  <span class="attr">image:</span> <span class="string">"<span class="template-variable">&#123;&#123; .Values.global.registry.url &#125;&#125;</span>/<span class="template-variable">&#123;&#123; .Values.imageCredentials.repoPath &#125;&#125;</span>/<span class="template-variable">&#123;&#123;    .Values.initContainers.coredumps.images.name &#125;&#125;</span>:<span class="template-variable">&#123;&#123; .Values.initContainers.coredumps.images.tag &#125;&#125;</span>"</span></span><br><span class="line">  <span class="attr">command:</span> <span class="string">['sh',</span> <span class="string">'-c'</span><span class="string">,</span> <span class="string">'ulimit -c unlimited; echo "<span class="template-variable">&#123;&#123;    .Values.initContainers.coredumps.service.dst &#125;&#125;</span>/core.%e.%p.%h.%t" &gt; /proc/sys/kernel/   core_pattern;'</span><span class="string">]</span></span><br><span class="line">  <span class="attr">securityContext:</span></span><br><span class="line">    <span class="attr">privileged:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>为需要生成coredump的container加上个volumeMounts.</p>
 <figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">volumeMounts:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">dumps</span></span><br><span class="line">  <span class="attr">mountPath:</span> <span class="string">&#123;&#123;</span> <span class="string">.Values.initContainers.coredumps.service.dst</span> <span class="string">&#125;&#125;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>添加下面code在你的value.yaml 里面 (如何你在第一步里面是hardcode的话，这里可以省略)</p>
 <figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># here image i used suse, you can use "docker pull registry.suse.com/suse/sles12sp4" pull ito     your local</span></span><br><span class="line"><span class="comment"># and then use "docker tag xxx bbb" command to retag it(this command can omit if you usorigin     tag directly)   </span></span><br><span class="line"><span class="attr">initContainers:</span></span><br><span class="line">  <span class="attr">coredumps:</span></span><br><span class="line">    <span class="attr">images:</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">xxx</span></span><br><span class="line">      <span class="attr">tag:</span> <span class="number">1.</span><span class="string">xxx</span></span><br><span class="line">    <span class="attr">service:</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">coredumps</span></span><br><span class="line">      <span class="attr">dst:</span> <span class="string">/root/dumps</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="用debug模式编译代码，然后docker-build一个image"><a href="#用debug模式编译代码，然后docker-build一个image" class="headerlink" title="用debug模式编译代码，然后docker build一个image."></a>用debug模式编译代码，然后docker build一个image.</h2><ul>
<li>可参考下面命令生成image <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> <span class="string">"."</span> means current directory</span></span><br><span class="line">docker build XXXX .</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="更新你的image到deployment里面"><a href="#更新你的image到deployment里面" class="headerlink" title="更新你的image到deployment里面."></a>更新你的image到deployment里面.</h2><p>这里有两个方案：</p>
<ul>
<li><p>用下面命令直接在线修改你的deployment, k8s通过重启pod动态生效.</p>
 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kubectl edit deploy your_deployment_name</span><br></pre></td></tr></table></figure>
</li>
<li><p>修改本地deployment.yaml 文件，然后在kubectl upgrade更新(基于helm install的方式).</p>
</li>
</ul>
<h2 id="找到你挂载的coredump-文件映射到本地的具体目录"><a href="#找到你挂载的coredump-文件映射到本地的具体目录" class="headerlink" title="找到你挂载的coredump 文件映射到本地的具体目录."></a>找到你挂载的coredump 文件映射到本地的具体目录.</h2><ul>
<li><p>可参考下面命令</p>
 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker ps | grep ApplicationName  #to found container id .</span><br><span class="line">docker inspect container id | grep dump #to found dir that docker volume mapped local dir.</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="将生成的coredump文件拷贝到你本地目录"><a href="#将生成的coredump文件拷贝到你本地目录" class="headerlink" title="将生成的coredump文件拷贝到你本地目录."></a>将生成的coredump文件拷贝到你本地目录.</h2><p><strong>Note:</strong> 其实好像还有个docker cp 命令可以拷贝文件，但是我没有在这个情况亲自尝试过，这是用过将本地文件copy到container里面 . 具体怎么使用,可以参考官网指导 <a href="https://docs.docker.com/engine/reference/commandline/cp/" target="_blank" rel="noopener">docker cp command guidance</a>.</p>
<h2 id="gdb调试你的程序"><a href="#gdb调试你的程序" class="headerlink" title="gdb调试你的程序."></a>gdb调试你的程序.</h2><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文讲的方式是在主container运行之前，启动一个定制的initContainer，目的是将coredump默认生成文件目录修改到自己设定的目录下。然后就可以将coredump文件弄出到本地，进行debug分析。</p>
<h2 id="参考文章："><a href="#参考文章：" class="headerlink" title="参考文章："></a>参考文章：</h2><p>k8s init container 官方说明： <a href="https://kubernetes.io/docs/concepts/workloads/pods/init-containers/" target="_blank" rel="noopener">k8s init container</a>  \<br>k8s empty dir 官方说明：<a href="https://kubernetes.io/docs/concepts/storage/volumes/#emptydir" target="_blank" rel="noopener">k8s empty Dir</a></p>
]]></content>
      <categories>
        <category>MicroService</category>
      </categories>
      <tags>
        <tag>Docker</tag>
        <tag>coredump</tag>
      </tags>
  </entry>
  <entry>
    <title>Profiling  C++ with Perf in the linux Env</title>
    <url>/2019/12/Profiling-C-with-Perf-in-the-linux-Env/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="Installation-perf"><a href="#Installation-perf" class="headerlink" title="Installation perf"></a>Installation perf</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">uname -r    # check your system tools version for the third command</span><br><span class="line">sudo apt-get install linux-tools-common</span><br><span class="line">sudo apt-get install linux-tools-4.15.0-47-generic linux-cloud-tools-4.15.0-47-generic</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h2 id="Special-setup"><a href="#Special-setup" class="headerlink" title="Special setup"></a>Special setup</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo sysctl kernel.perf_event_paranoid=-1</span><br><span class="line">sudo sysctl kernel.kptr_restrict=0</span><br></pre></td></tr></table></figure>
<h2 id="record-perf-sample"><a href="#record-perf-sample" class="headerlink" title="record perf sample"></a>record perf sample</h2><h3 id="Option-1-record-perf-after-you-started-application"><a href="#Option-1-record-perf-after-you-started-application" class="headerlink" title="Option 1: record perf after you started application"></a>Option 1: record perf after you started application</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./application_name</span><br><span class="line"></span><br><span class="line">perf record -g -s -p `ps -ef | grep application_name | grep -v grep | awk '&#123;print $2&#125;'`</span><br></pre></td></tr></table></figure>
<h3 id="Option-2-record-perf-when-you-start-application"><a href="#Option-2-record-perf-when-you-start-application" class="headerlink" title="Option 2: record perf when you start application"></a>Option 2: record perf when you start application</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">perf record -g -s ./application_name</span><br></pre></td></tr></table></figure>
<h2 id="run-load-h2load"><a href="#run-load-h2load" class="headerlink" title="run load (h2load)"></a>run load (h2load)</h2><h2 id="check-report-report-will-store-a-file-called-perf-data"><a href="#check-report-report-will-store-a-file-called-perf-data" class="headerlink" title="check report (report will store a file called perf.data)"></a>check report (report will store a file called perf.data)</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">perf report -d applicationname -g graph,0.05,caller,function or perf report</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>MicroService</category>
      </categories>
      <tags>
        <tag>Profil</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>how to install Docker CE in the Ubuntu 18.04</title>
    <url>/2019/12/how-to-install-Docker-CE-in-the-Ubuntu-18-04/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="following-offical-docs-to-install-it-a-perfect-method"><a href="#following-offical-docs-to-install-it-a-perfect-method" class="headerlink" title="following offical docs to install it a perfect method."></a>following offical docs to install it a perfect method.</h2><p>Docker CE offcial docs : <a href="https://docs.docker.com/install/linux/docker-ce/ubuntu/" target="_blank" rel="noopener">docker offical docs</a></p>
<a id="more"></a>
<p><strong>Notes:</strong><br>Maybe you will appear docker-ce-cli not found issue,when using following command which written by docker formal docs to install docker ce. you can refernce my solution to solve it.</p>
<p>remove <strong><em>“docker-ce-cli=&lt;VERSION_STRING&gt;”</em></strong>  part from following command . and you can also reference <a href="https://stackoverflow.com/questions/54471543/e-version-18-06-1ce3-0ubuntu-for-docker-ce-cli-was-not-found" target="_blank" rel="noopener">ubuntu-for-docker-ce-cli-was-not-found</a></p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">sudo apt-<span class="built_in">get</span> install docker-<span class="keyword">ce</span>=<span class="symbol">&lt;VERSION_STRING&gt;</span>docker-<span class="keyword">ce</span>-cli=<span class="symbol">&lt;VERSION_STRING&gt;</span> containerd.io</span><br></pre></td></tr></table></figure>
<h2 id="Add-root-permission-for-docker-command"><a href="#Add-root-permission-for-docker-command" class="headerlink" title="Add root permission for docker command."></a>Add root permission for docker command.</h2><figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="attribute">sudo</span> groupadd docker;<span class="attribute">sudo</span> usermod -aG docker <span class="variable">$USER</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>MicroService</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>github上将源repo提交更新到fork的repo</title>
    <url>/2019/12/github%E4%B8%8A%E5%B0%86%E6%BA%90repo%E6%8F%90%E4%BA%A4%E6%9B%B4%E6%96%B0%E5%88%B0fork%E7%9A%84repo/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在github上 一般我们都是将别人的repo fork到自己的github repo。 然后阅读，修改 甚至是contribution。所以同步源repo的commit 尤为重要。因为你要始终保持与源repo同步。下面将描述下怎么去同步更新的步骤。<br><a id="more"></a></p>
<h2 id="将源repo-https-link-加到自己本地-repo-的remote-upstream中。添加之后，如果你想查看是否加入成功。可以使用git-remote-v"><a href="#将源repo-https-link-加到自己本地-repo-的remote-upstream中。添加之后，如果你想查看是否加入成功。可以使用git-remote-v" class="headerlink" title="将源repo https link 加到自己本地 repo 的remote upstream中。添加之后，如果你想查看是否加入成功。可以使用git remote -v"></a>将源repo https link 加到自己本地 repo 的remote upstream中。添加之后，如果你想查看是否加入成功。可以使用git remote -v</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git remote add upstream https://github.com/ORIGINAL_OWENER/ORIGINAL_REPO.git</span><br></pre></td></tr></table></figure>
<h2 id="fetch源repo的最新提交到本地，然后merge到自己的repo"><a href="#fetch源repo的最新提交到本地，然后merge到自己的repo" class="headerlink" title="fetch源repo的最新提交到本地，然后merge到自己的repo"></a>fetch源repo的最新提交到本地，然后merge到自己的repo</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git fetch upstream</span><br><span class="line">git checkout master   #if you current branch isn't master</span><br><span class="line">git merge upstream/master</span><br></pre></td></tr></table></figure>
<p>或者用下面这条命令代替上面三条命令</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">upstream代表远端源repo </span></span><br><span class="line"><span class="meta">#</span><span class="bash">master 代表你forked repo的master 分支 </span></span><br><span class="line">git pull upstream master</span><br></pre></td></tr></table></figure>
<h2 id="将自己repo的合并后的，提交到github上。"><a href="#将自己repo的合并后的，提交到github上。" class="headerlink" title="将自己repo的合并后的，提交到github上。"></a>将自己repo的合并后的，提交到github上。</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git push origin master</span><br></pre></td></tr></table></figure>
<p><strong><em>Note:</em></strong> 如何强制覆盖github上的commit, <strong><em>此命令慎用</em></strong><br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git push -f origin master</span><br></pre></td></tr></table></figure></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在合作开发的时候，还是时不时的rebase下是最好的，避免不必要的冲突麻烦。</p>
]]></content>
      <categories>
        <category>github</category>
      </categories>
      <tags>
        <tag>github</tag>
        <tag>git</tag>
      </tags>
  </entry>
</search>
